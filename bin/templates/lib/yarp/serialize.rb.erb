require "stringio"

module YARP
  module Serialize
    def self.load(source, serialized)
      io = StringIO.new(serialized)
      io.set_encoding(Encoding::BINARY)
      Loader.new(source, io).load
    end

    class Loader
      attr_reader :source, :io, :encoding

      def initialize(source, io)
        @source = source.b
        @io = io
        @encoding = Encoding::UTF_8
      end

      def load
        io.read(4) => "YARP"
        io.read(3).unpack("C3") => [0, 4, 0]
        load_node
      end

      private

      def load_integer
        n = io.getbyte
        if n < 128
          n
        else
          n -= 128
          shift = 0
          while (b = io.getbyte) >= 128
            n += (b - 128) << (shift += 7)
          end
          n + (b << (shift + 7))
        end
      end

      def load_serialized_length
        io.read(4).unpack1("L")
      end

      def load_token
        number = io.getbyte
        location = load_location

        type =
          case number
          <%- tokens.each_with_index do |token, index| -%>
          when <%= index + 1 %> then :<%= token.name %>
          <%- end -%>
          end

        # This is wrong, we should be dumping and loading the encoding. For now,
        # we assume that the source is UTF-8.
        range = source[location.start_offset...location.end_offset]
        Token.new(type, range.force_encoding(encoding), location)
      end

      def load_optional_node
        if io.getbyte != 0
          io.pos -= 1
          load_node
        end
      end

      def load_optional_token
        if io.getbyte != 0
          io.pos -= 1
          load_token
        end
      end

      def load_string
        length = load_integer
        io.read(length).force_encoding(encoding)
      end

      def load_location
        start_offset, length = load_integer, load_integer
        end_offset = start_offset + length
        Location.new(start_offset, end_offset)
      end

      def load_optional_location
        load_location if io.getbyte != 0
      end

      def load_node
        type = io.getbyte
        location = load_location

        case type
        <%- nodes.each_with_index do |node, index| -%>
        when <%= index + 1 %> then
        <%- if node.needs_length? -%>
          load_serialized_length
        <%- end -%>
        <%= node.name %>.new(<%= (node.params.map { |param|
          case param
          when NodeParam then "load_node"
          when OptionalNodeParam then "load_optional_node"
          when StringParam then "load_string"
          when NodeListParam then "load_integer.times.map { load_node }"
          when TokenParam then "load_token"
          when TokenListParam then "load_integer.times.map { load_token }"
          when OptionalTokenParam then "load_optional_token"
          when LocationParam then "load_location"
          when OptionalLocationParam then "load_optional_location"
          when IntegerParam then 'load_integer'
          else raise
          end
        } + ["location"]).join(", ") -%>)
        <%- end -%>
        end
      end
    end
  end
end
